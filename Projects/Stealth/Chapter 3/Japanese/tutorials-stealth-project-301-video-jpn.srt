1
00:00:00,000 --> 00:00:01,911
この課題ではカメラの動作について

2
00:00:01,911 --> 00:00:03,911
対応を進めていきます。

3
00:00:03,911 --> 00:00:05,771
制御が正しく動作するために

4
00:00:05,771 --> 00:00:07,771
カメラはワールド座標空間の Z 軸の正方向に

5
00:00:07,771 --> 00:00:09,771
向く必要があります。

6
00:00:10,271 --> 00:00:11,804
これはユーザが上方向のキーを押下したとき

7
00:00:11,804 --> 00:00:14,179
プレイヤーが Z 軸の正方向に

8
00:00:14,179 --> 00:00:16,179
移動して、

9
00:00:16,179 --> 00:00:18,179
これは画面上で上方向の動作

10
00:00:18,179 --> 00:00:20,179
につながります。カメラを X 軸および Y 軸の

11
00:00:20,179 --> 00:00:22,179
負の方向にわずかに

12
00:00:22,179 --> 00:00:23,871
向けます。

13
00:00:23,871 --> 00:00:25,871
これにより、カメラを極端にどちらかの方向に

14
00:00:25,871 --> 00:00:27,871
向けないかぎり制御に悪影響を

15
00:00:27,871 --> 00:00:29,871
与えません。ちょうど良いとおもうビューを

16
00:00:29,871 --> 00:00:31,871
得るためには、いずれメイン カメラ を合わせたいようにシーンのカメラの位置を

17
00:00:31,871 --> 00:00:34,288
プレイヤーに向けるべきです。

18
00:00:35,075 --> 00:00:37,075
次のように表示されます。

19
00:00:39,674 --> 00:00:41,454
これが完了した後、

20
00:00:41,454 --> 00:00:44,699
camera_main をハイライトして、

21
00:00:44,699 --> 00:00:46,699
ゲーム オブジェクトのメニューから Align With View を選択します。

22
00:00:47,337 --> 00:00:49,337
これによりゲームビューと

23
00:00:49,337 --> 00:00:50,945
シーンビューのカメラが同じ方向になりました。

24
00:00:50,945 --> 00:00:52,945
これでシーンビューカメラを好きな方向に

25
00:00:52,945 --> 00:00:54,153
向けて問題ありません。

26
00:00:54,860 --> 00:00:56,860
カメラが同じ方向を向いているので

27
00:00:56,860 --> 00:00:58,860
動作を制御するスクリプトを作成していきます。

28
00:00:58,860 --> 00:01:01,988
camera_main に新しいスクリプト コンポーネントを作成して

29
00:01:02,488 --> 00:01:04,488
CameraMovement をコールします。

30
00:01:07,046 --> 00:01:09,046
アイコンをダブルクリックして編集し、

31
00:01:09,046 --> 00:01:11,046
次にスクリプトをクリアします。

32
00:01:15,455 --> 00:01:17,455
このクラスには public である変数が

33
00:01:17,455 --> 00:01:19,858
ひとつだけ必要です。この float 型の変数により

34
00:01:19,858 --> 00:01:21,858
カメラ動作のスムージングを制御します。

35
00:01:23,670 --> 00:01:25,670
private 変数については、

36
00:01:25,670 --> 00:01:27,670
初めにプレイヤーの Transform への参照を用意して

37
00:01:27,670 --> 00:01:29,670
Position を取得します。

38
00:01:31,786 --> 00:01:34,130
private 変数はもういくつか必要です。

39
00:01:34,130 --> 00:01:36,130
カメラがプレイヤーをトラッキングする 

40
00:01:36,130 --> 00:01:37,838
Position の調整が簡単になるように、

41
00:01:37,838 --> 00:01:39,379
プレイヤーに対して相対的に

42
00:01:39,379 --> 00:01:41,656
カメラの位置を格納します。

43
00:01:41,656 --> 00:01:43,656
これは Vector3 に格納します。

44
00:01:44,764 --> 00:01:46,666
プレイヤーが障害物の後ろに移動すると

45
00:01:46,666 --> 00:01:48,666
カメラが上方向に Pan（移動）をして

46
00:01:48,666 --> 00:01:50,666
プレイヤーを表示できるようにして

47
00:01:50,666 --> 00:01:52,404
カメラが潜在的にいることができる Position は

48
00:01:52,404 --> 00:01:54,154
複数あります。

49
00:01:54,573 --> 00:01:56,337
これらの Position がプレイヤーから等距離である

50
00:01:56,337 --> 00:01:58,337
ことを保証するため、

51
00:01:58,337 --> 00:02:00,337
相対的な位置ベクトルの Magnitude (大きさ) を

52
00:02:00,337 --> 00:02:02,017
使用する必要があります。

53
00:02:02,561 --> 00:02:04,561
これを毎フレーム計算するのでなく、

54
00:02:04,561 --> 00:02:06,561
それは高価なことなので

55
00:02:06,561 --> 00:02:09,298
この Magnitude を float 型の変数に格納します。

56
00:02:10,539 --> 00:02:12,192
カメラが移動するときの

57
00:02:12,192 --> 00:02:14,192
この新しい位置を計算した後、

58
00:02:14,192 --> 00:02:16,192
その値を格納をして、

59
00:02:16,192 --> 00:02:17,693
カメラの現在の位置と

60
00:02:17,693 --> 00:02:19,693
この新しい位置とを Lerp させる必要があります。

61
00:02:21,436 --> 00:02:23,436
次に Awake 関数を使用して

62
00:02:23,436 --> 00:02:25,798
参照のセットアップを行ないます。初めに

63
00:02:25,798 --> 00:02:27,798
プレイヤーへの参照が必要です。

64
00:02:31,613 --> 00:02:32,973
プレイヤーからのカメラの相対位置は

65
00:02:32,973 --> 00:02:34,973
カメラの位置から

66
00:02:34,973 --> 00:02:36,973
プレイヤーの位置を引き算することで算出します。

67
00:02:39,725 --> 00:02:41,725
相対位置の Magnitude は、

68
00:02:41,725 --> 00:02:43,725
プレイヤーとカメラとの距離です。

69
00:02:43,725 --> 00:02:45,725
少し調整を行なうために

70
00:02:45,725 --> 00:02:47,725
少しの量だけ減少させます。

71
00:02:47,725 --> 00:02:49,725
プレイヤーの位置は

72
00:02:49,725 --> 00:02:51,949
足元の高さであるため、プレイヤーへの Raycast をして、

73
00:02:51,949 --> 00:02:53,949
何かが、間にあるか確認するときに、

74
00:02:53,949 --> 00:02:55,949
もしわずかに減らすことをしないと

75
00:02:55,949 --> 00:02:57,949
地面にあたることになります。

76
00:02:59,167 --> 00:03:01,167
カメラには FixedUpdate 関数を使用して

77
00:03:01,167 --> 00:03:03,922
位置の更新を行ないます。

78
00:03:03,922 --> 00:03:05,922
この理由は、自身は物理オブジェクトではないものの

79
00:03:05,922 --> 00:03:07,686
物理オブジェクトを追跡するためです。

80
00:03:07,686 --> 00:03:09,686
動作を

81
00:03:09,686 --> 00:03:11,686
できるかぎりスムーズにするには

82
00:03:11,686 --> 00:03:14,372
両方の Update は同時に起こる必要があります。

83
00:03:15,898 --> 00:03:17,898
次にすべてのカメラの相対位置を

84
00:03:17,898 --> 00:03:19,898
格納する必要があります。

85
00:03:19,898 --> 00:03:21,898
カメラの標準位置から始めますが、

86
00:03:21,898 --> 00:03:23,898
この位置はプレイヤーの位置に

87
00:03:23,898 --> 00:03:25,898
カメラの相対位置を足し算したものです。

88
00:03:29,837 --> 00:03:31,837
次にカメラがプレイヤーを真っ直ぐ下の向きに

89
00:03:31,837 --> 00:03:34,114
みているときの位置を格納します。

90
00:03:34,627 --> 00:03:36,627
これはプレイヤーの位置に

91
00:03:36,627 --> 00:03:39,207
相対的なカメラの位置から

92
00:03:39,207 --> 00:03:41,207
真っ直ぐ上方向の直線の Magnitude です。

93
00:03:46,113 --> 00:03:48,113
カメラの標準位置が

94
00:03:48,113 --> 00:03:49,337
あり、プレイヤーの真上にあるときの位置があるため、

95
00:03:49,337 --> 00:03:51,337
あとはそれらの間でいくつかの

96
00:03:51,337 --> 00:03:52,964
位置を決定する必要があります。

97
00:03:53,409 --> 00:03:56,115
これらの位置を配列として整理します。

98
00:03:56,615 --> 00:03:58,296
これによりカメラが

99
00:03:58,296 --> 00:03:59,605
どの位置を選択するか

100
00:03:59,605 --> 00:04:01,174
より簡単に選択できます。

101
00:04:01,663 --> 00:04:03,663
もし標準位置、真上の位置、

102
00:04:03,663 --> 00:04:06,406
そしてその間で 3 つの位置がある場合、

103
00:04:06,406 --> 00:04:09,176
全部で 5 つの Vector3 の配列が必要です。

104
00:04:09,676 --> 00:04:11,676
これらの位置から

105
00:04:11,676 --> 00:04:13,676
プレイヤーの位置をカメラがみることができるかチェックするので、

106
00:04:13,676 --> 00:04:15,676
配列の名前は checkPoints とします。

107
00:04:18,441 --> 00:04:20,441
最初にチェックを行なう位置は

108
00:04:20,441 --> 00:04:22,441
標準位置にします。

109
00:04:25,289 --> 00:04:27,289
標準位置と

110
00:04:27,289 --> 00:04:29,289
真上の位置の間の位置をみつけるために

111
00:04:29,289 --> 00:04:31,289
Lerp 関数を

112
00:04:31,289 --> 00:04:32,609
これまでとは別の方法で

113
00:04:32,609 --> 00:04:33,938
使用します。

114
00:04:34,438 --> 00:04:36,438
Lerp 関数で行なうことは

115
00:04:36,438 --> 00:04:38,438
二つの値の間の割合を占める値を

116
00:04:38,438 --> 00:04:40,158
戻り値とします。

117
00:04:40,158 --> 00:04:42,158
二つの値のうち

118
00:04:42,158 --> 00:04:44,158
どの地点を戻すかは

119
00:04:44,158 --> 00:04:45,198
3 つめの引数に依存します。

120
00:04:45,698 --> 00:04:48,488
0 では一つめの値を戻り値として、

121
00:04:48,488 --> 00:04:51,151
1 では二つめの値を戻り値とします。

122
00:04:51,844 --> 00:04:53,844
もし 0 と 1 の間の値である場合、

123
00:04:53,844 --> 00:04:56,424
Lerp により二つの値の間のどこかにある

124
00:04:56,424 --> 00:04:58,424
値を戻り値とします。

125
00:04:59,007 --> 00:05:01,007
例えば、二つの Vector3 を与えて

126
00:05:01,007 --> 00:05:04,211
さらに 三つめのパラメータを 0.5 とした場合、

127
00:05:04,211 --> 00:05:06,211
Lerp により 二つの中間の位置にある

128
00:05:06,211 --> 00:05:07,359
Vector3 を戻り値とします。

129
00:05:07,859 --> 00:05:09,553
この方法を使用して、

130
00:05:09,553 --> 00:05:13,911
25%, 50%, および 75% の位置を

131
00:05:13,911 --> 00:05:15,911
標準位置と真上の位置

132
00:05:15,911 --> 00:05:17,911
間にある地点をみつけてきます。

133
00:05:31,615 --> 00:05:33,615
配列の最後の位置は

134
00:05:33,615 --> 00:05:35,062
真上の位置です。

135
00:05:37,054 --> 00:05:39,054
カメラがプレイヤーをみることができるか

136
00:05:39,054 --> 00:05:41,054
チェックを行なう全ての位置をみつけた後、

137
00:05:41,054 --> 00:05:43,054
どれがみることできるかのループを

138
00:05:43,054 --> 00:05:44,460
行なうことができます。

139
00:05:47,391 --> 00:05:49,197
関数を作成することで、これらの位置をチェックし、

140
00:05:49,197 --> 00:05:51,711
さらにカメラがプレイヤーを

141
00:05:51,711 --> 00:05:53,311
みつけることができる場合は

142
00:05:53,311 --> 00:05:54,961
newPos 変数をセットします。

143
00:05:54,961 --> 00:05:56,961
この関数はプレイヤーがカメラをみることが出来るとき

144
00:05:56,961 --> 00:05:58,961
true を戻り値とすべきです。

145
00:06:00,718 --> 00:06:02,718
チェックする位置からの

146
00:06:02,718 --> 00:06:04,718
Raycast を使用して

147
00:06:04,718 --> 00:06:06,952
プレイヤーか何かほかのものをヒットしたか確認します。

148
00:06:06,952 --> 00:06:08,952
最初に行なうべきことは

149
00:06:08,952 --> 00:06:10,952
RaycastHit を作成して、

150
00:06:10,952 --> 00:06:12,340
チェックするものを作成するものを用意します。

151
00:06:13,908 --> 00:06:15,908
次に Raycast を実行して

152
00:06:15,908 --> 00:06:18,448
ヒットするかどうか確認します。Raycast が

153
00:06:18,448 --> 00:06:20,448
チェックする位置を開始位置とさせて

154
00:06:20,448 --> 00:06:22,448
プレイヤーの位置に向かせる必要があります。

155
00:06:22,448 --> 00:06:24,448
RaycastHit から情報を取得して

156
00:06:24,448 --> 00:06:26,448
Raycast の長さは

157
00:06:26,448 --> 00:06:28,036
カメラからのプレイヤーの

158
00:06:28,036 --> 00:06:29,285
距離とします。

159
00:06:32,893 --> 00:06:34,893
Raycast が何かにヒットした場合、

160
00:06:34,893 --> 00:06:36,893
次にヒットしたオブジェクトの Transform が

161
00:06:36,893 --> 00:06:38,893
プレイヤーの Transform でないことを

162
00:06:38,893 --> 00:06:40,893
確認します。

163
00:06:42,015 --> 00:06:44,015
もしヒットしたものがプレイヤーでない場合、

164
00:06:44,015 --> 00:06:46,015
その位置を使用することが出来ません。

165
00:06:46,015 --> 00:06:48,446
この場合、この関数から false を戻します。

166
00:06:48,902 --> 00:06:50,902
もし Raycast で何もヒットをしなかった場合、

167
00:06:50,902 --> 00:06:53,510
あるいは何かをヒットしたけどプレイヤーであった場合

168
00:06:53,510 --> 00:06:55,274
チェックする位置は

169
00:06:55,274 --> 00:06:56,888
カメラとしては問題ありません。

170
00:06:56,888 --> 00:06:58,888
newPos 変数をセットして

171
00:06:58,888 --> 00:07:00,888
関数から true を戻します。

172
00:07:02,838 --> 00:07:04,383
次に関数をループの中から

173
00:07:04,383 --> 00:07:06,383
コールする必要があります。

174
00:07:06,383 --> 00:07:08,383
正しい位置をみつけた場合にどうするかも

175
00:07:08,383 --> 00:07:10,907
考慮する必要があります。もし

176
00:07:10,907 --> 00:07:12,907
ループを継続する場合、

177
00:07:12,907 --> 00:07:14,907
最後に適切であった位置をみつけるため、

178
00:07:14,907 --> 00:07:16,907
真上の位置をみつけることになります。

179
00:07:17,407 --> 00:07:19,407
このため、最初の適切な位置をみつけたとき

180
00:07:19,407 --> 00:07:21,407
ループから抜ける必要があります。

181
00:07:21,407 --> 00:07:23,939
このためには break キーワードを使用します。

182
00:07:24,460 --> 00:07:26,460
break キーワードにより

183
00:07:26,460 --> 00:07:28,930
どのループに配置されていてもそこから抜けます。

184
00:07:28,930 --> 00:07:30,930
似た方法は return キーワードを使用して

185
00:07:30,930 --> 00:07:32,392
自身が入っているコードから

186
00:07:32,392 --> 00:07:34,392
出ます。しかし return は関数に対しての

187
00:07:34,392 --> 00:07:37,605
動作であるのに対して、 break はループに対して動作します。

188
00:07:41,406 --> 00:07:42,812
これでカメラの新しい位置が選ばれたので

189
00:07:42,812 --> 00:07:44,812
位置を現在の位置と新しい位置との間で

190
00:07:44,812 --> 00:07:48,213
Lerp を行ないます。

191
00:07:50,398 --> 00:07:52,160
カメラが適切な位置に移動しているので

192
00:07:52,160 --> 00:07:54,160
正しい方向に向けて

193
00:07:54,160 --> 00:07:55,776
表示を行なっていることを確認する必要が

194
00:07:55,776 --> 00:07:58,607
あります。これを行なう簡単な方法は

195
00:07:58,607 --> 00:08:01,263
transform.LookAt を使用することです。

196
00:08:01,263 --> 00:08:02,808
しかし、これにより

197
00:08:02,808 --> 00:08:04,808
FixedUpdate ごとに毎回

198
00:08:04,808 --> 00:08:06,808
カメラがプレイヤーに向くため

199
00:08:06,808 --> 00:08:08,444
プレイヤーが移動するたびにぎこちなくなり、

200
00:08:08,444 --> 00:08:10,250
これは過剰に正確な位置へすぐに向けるとするためです。

201
00:08:10,250 --> 00:08:12,250
この代わりに、カメラにはスムージングして

202
00:08:12,250 --> 00:08:14,250
向きを変えるようにさせたいため

203
00:08:14,250 --> 00:08:16,250
smoothLookAt 関数をその代わりに作成

204
00:08:16,250 --> 00:08:17,777
します。

205
00:08:18,819 --> 00:08:20,391
同じような方法を使用して

206
00:08:20,391 --> 00:08:22,391
プレイヤーの向きを

207
00:08:22,391 --> 00:08:24,774
入力に応じて変更します。

208
00:08:24,774 --> 00:08:26,774
カメラからプレイヤーに向けた Vector3 を取得して

209
00:08:26,774 --> 00:08:28,774
そのためのクォータニオンを

210
00:08:28,774 --> 00:08:31,483
生成します。これは

211
00:08:31,483 --> 00:08:33,776
カメラに行なわせたい回転となります。

212
00:08:34,218 --> 00:08:36,218
取得ができた後は、

213
00:08:36,218 --> 00:08:38,218
カメラの現在の回転と、新しい回転との間で

214
00:08:38,218 --> 00:08:40,822
Lerp を使用することが出来ます。

215
00:08:40,822 --> 00:08:43,720
初めにカメラからプレイヤーに向けたベクトルが必要です。

216
00:08:45,546 --> 00:08:47,546
次に PlayerMovement スクリプトで出てくる

217
00:08:47,546 --> 00:08:50,445
LookRotation 関数を使用します。

218
00:08:50,445 --> 00:08:52,445
これにより Forward ベクトルが与えられたオブジェクトの

219
00:08:52,445 --> 00:08:55,110
回転をあらわすクォータニオンを戻り値と

220
00:08:55,110 --> 00:08:57,442
します。さらに Up ベクトルを準備して

221
00:08:57,442 --> 00:08:59,442
カメラが確かに上方向であるかを

222
00:08:59,442 --> 00:09:01,442
確認します。

223
00:09:04,884 --> 00:09:06,884
最終的に、

224
00:09:06,884 --> 00:09:08,995
自身と新しく生成した回転の間で、

225
00:09:08,995 --> 00:09:10,995
カメラの回転を Lerp できます。

226
00:09:16,352 --> 00:09:18,202
このスクリプトで最後に行なうべきことは

227
00:09:18,202 --> 00:09:21,098
SmoothLookAt 関数に対するコールを配置することです。

228
00:09:23,173 --> 00:09:25,173
スクリプトが完成したので、保存をして

229
00:09:25,173 --> 00:09:27,173
エディタに戻ります。

230
00:09:30,753 --> 00:09:33,785
ここでも Scripts フォルダを整頓します。

231
00:09:33,785 --> 00:09:35,785
プロジェクトパネルの Scripts フォルダを開いて

232
00:09:36,285 --> 00:09:39,436
Player フォルダの中に PlayerHealth スクリプトをドラッグします。

233
00:09:40,198 --> 00:09:42,198
CameraMovement スクリプトについては新しい

234
00:09:42,198 --> 00:09:43,745
サブフォルダに配置します。

235
00:09:44,505 --> 00:09:46,505
LevelDynamics というフォルダを作成して

236
00:09:46,505 --> 00:09:48,505
Assets フォルダから、その中に

237
00:09:48,505 --> 00:09:50,505
CameraMovement スクリプトをドラッグします。

238
00:09:55,591 --> 00:09:57,591
次にシーンんおテスト再生を行ないます。

239
00:09:57,591 --> 00:09:59,591
画面上部で Play ボタンをクリックすると、

240
00:10:04,815 --> 00:10:06,664
みてのとおり、キャラクターはレベルの中を

241
00:10:06,664 --> 00:10:08,664
走り回って、カメラがそのトラッキングを行なってくれます。

242
00:10:10,020 --> 00:10:11,632
みてのとおり壁に近づくと

243
00:10:11,632 --> 00:10:14,283
カメラはより真上に近い位置に移動していきます

244
00:10:15,057 --> 00:10:17,057
逆に遠ざかるにつれて少し下のほうの傾けたところに

245
00:10:17,057 --> 00:10:19,472
配列で割合を指定した位置のいずれかに

246
00:10:19,472 --> 00:10:21,472
移動します。

247
00:10:26,295 --> 00:10:27,964
移動するキャラクターが

248
00:10:27,964 --> 00:10:29,964
アラームのトリガーをできることも頭に入れてください。

249
00:10:39,953 --> 00:10:42,829
Play ボタンを再び押下してテストを停止します。

250
00:10:42,829 --> 00:10:44,829
最後に、シーンを保存して

251
00:10:45,329 --> 00:10:47,329
プロジェクトを保存します。

252
00:10:48,810 --> 00:10:50,810
次の課題では

253
00:10:50,810 --> 00:10:53,680
昇降エレベータのロックを外す鍵を追加します。
(翻訳:gamesonytablet)
