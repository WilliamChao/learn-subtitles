1
00:00:00,773 --> 00:00:02,768
配列とは、同じ型のデータの集合を

2
00:00:02,768 --> 00:00:04,768
まとめて格納する手段のひとつです。

3
00:00:05,268 --> 00:00:07,932
例えば 5 つの integer を格納する必要があるとします。

4
00:00:07,932 --> 00:00:09,932
個別に myIntA, myIntB, myIntC などと

5
00:00:09,932 --> 00:00:13,360
名前をつけて管理せず

6
00:00:13,360 --> 00:00:15,360
まとめて配列として格納出来ます。

7
00:00:15,360 --> 00:00:17,360
配列を宣言するのは、

8
00:00:17,360 --> 00:00:19,360
個別に変数を宣言するのと似た方法でやります。

9
00:00:19,360 --> 00:00:21,360
違いといえば変数の型の後に

10
00:00:21,360 --> 00:00:24,492
[] 記号を使用することです。

11
00:00:24,492 --> 00:00:26,115
覚えるべき重要なことは

12
00:00:26,115 --> 00:00:28,879
配列は型でなく、むしろある型の変数の

13
00:00:28,879 --> 00:00:30,879
集合だということです。

14
00:00:30,879 --> 00:00:32,879
配列を使用する前に

15
00:00:32,879 --> 00:00:34,879
長さを知る必要があります。長さとは、言いかえると

16
00:00:34,879 --> 00:00:37,460
格納する要素の数です。要素とは配列において

17
00:00:37,460 --> 00:00:39,180
アイテムと呼ばれます。

18
00:00:39,846 --> 00:00:43,088
長さを指定するためには new キーワードを使用したうえで

19
00:00:43,088 --> 00:00:45,088
配列の型を指定して、

20
00:00:45,088 --> 00:00:48,150
要素の数を [] の中に指定します。

21
00:00:49,106 --> 00:00:51,018
配列の初期化については

22
00:00:51,018 --> 00:00:52,727
Start 関数の中で行います。

23
00:00:52,727 --> 00:00:55,977
配列の要素へのアクセスおよび初期化をするには

24
00:00:55,977 --> 00:00:57,739
配列の名前の後に

25
00:00:57,739 --> 00:01:00,086
要素のインデックス番号を [] の中に

26
00:01:00,086 --> 00:01:01,447
指定して下さい。

27
00:01:01,447 --> 00:01:04,016
要素のインデックスは integer を指定するのみであり、

28
00:01:04,016 --> 00:01:06,016
最初のインデックスは 0 から始まります。

29
00:01:06,016 --> 00:01:08,016
要素のインデックスを考えるうえで

30
00:01:08,016 --> 00:01:10,016
最初の要素から数えて何ステップだけ進めば

31
00:01:10,016 --> 00:01:11,589
アクセスできるか考えます。

32
00:01:11,589 --> 00:01:14,970
つまり最初の要素は

33
00:01:14,970 --> 00:01:17,772
最初の要素から 0 ステップ進んだ位置にあるので

34
00:01:17,772 --> 00:01:19,179
インデックスは 0 です。

35
00:01:19,179 --> 00:01:21,808
二つめの要素のインデックスは 1 と続いてきます。

36
00:01:21,808 --> 00:01:24,114
それでは配列に 5 つの要素があるケースで

37
00:01:24,114 --> 00:01:26,114
初期化してみます。

38
00:01:27,650 --> 00:01:29,650
配列を宣言して初期化するには

39
00:01:29,650 --> 00:01:32,542
これがひとつの記述方法です。しかし、もし一行で記述したければ

40
00:01:32,542 --> 00:01:34,542
それも実現することが出来ます。

41
00:01:35,042 --> 00:01:37,303
すなわち、配列の初期化と宣言を同時に

42
00:01:37,303 --> 00:01:39,303
行うことが出来ます。

43
00:01:39,803 --> 00:01:42,251
このためには関数、ループ、 if 文と同様に

44
00:01:42,251 --> 00:01:45,037
{} 記号を用います。

45
00:01:45,037 --> 00:01:47,037
{} 記号の中に

46
00:01:47,037 --> 00:01:49,037
配列で並べたい順序どおりに

47
00:01:49,037 --> 00:01:51,037
配列の値を指定してきます。

48
00:01:51,037 --> 00:01:52,829
これで 5 つの integer 型 の変数の配列が作成できました。

49
00:01:52,829 --> 00:01:54,829
前述のサンプルと同様にして、 12 から始まって

50
00:01:54,829 --> 00:01:56,732
次が 76 であり、その後も続いていきます。

51
00:01:57,136 --> 00:01:58,929
今回は配列の長さを明示的に記述していない

52
00:01:58,929 --> 00:02:00,929
ことに注目して下さい。配列の長さは

53
00:02:00,929 --> 00:02:02,542
{} 記号の中にある要素の数によって

54
00:02:02,542 --> 00:02:03,976
決定されます。

55
00:02:04,476 --> 00:02:06,476
このようにして配列を宣言すると

56
00:02:06,476 --> 00:02:08,476
本セクションの初めのサンプルどおりに

57
00:02:08,476 --> 00:02:11,211
アクセスすることが可能です。

58
00:02:12,968 --> 00:02:15,451
配列についてはいくつか注意すべき点があります。

59
00:02:15,451 --> 00:02:18,080
もし配列を public とした場合、

60
00:02:18,080 --> 00:02:19,638
インスペクタ上でも表示されるようになり、

61
00:02:19,638 --> 00:02:21,638
値を割り当てすることが出来ます。

62
00:02:22,138 --> 00:02:24,626
もしスクリプトを保存して元に戻ると、

63
00:02:25,126 --> 00:02:26,710
オブジェクトにアタッチしたときに

64
00:02:26,710 --> 00:02:28,710
player の配列は

65
00:02:28,710 --> 00:02:30,710
インスペクタ上で public 変数として表示され、

66
00:02:30,710 --> 00:02:33,681
配列の長さは Size 変数を使用して値を割り当てることが出来ます。

67
00:02:33,681 --> 00:02:36,472
つまり、 Size の値として 1 を入力すれば

68
00:02:36,472 --> 00:02:39,055
配列上に 1 つの要素が出来て

69
00:02:39,055 --> 00:02:41,055
ゲームオブジェクトをその上にドロップできるようになります。

70
00:02:41,055 --> 00:02:43,470
これは型がゲームオブジェクトであるためです。

71
00:02:43,470 --> 00:02:45,136
またスクリプトにより初期化をすることも出来ます。

72
00:02:45,136 --> 00:02:47,136
Unity にはいくつかの関数により

73
00:02:47,136 --> 00:02:49,765
この作業を行うことが出来ます。players の配列には

74
00:02:49,765 --> 00:02:51,765
このシーン上の全てのプレイヤーを格納していきます。

75
00:02:51,765 --> 00:02:54,335
FindGameObjectsWithTag 関数は

76
00:02:54,335 --> 00:02:56,335
シーン上で特定のタグのついた

77
00:02:56,335 --> 00:02:58,792
全てのゲームオブジェクトを配列として戻します。

78
00:02:59,292 --> 00:03:01,292
player ゲームオブジェクトはすべて player タグがあるため

79
00:03:01,292 --> 00:03:04,248
すべて渡すことが出来て、シーン上の全ての players を

80
00:03:04,248 --> 00:03:06,248
取得することが出来ます。

81
00:03:06,248 --> 00:03:08,248
この関数が戻す配列を使用して

82
00:03:08,248 --> 00:03:11,134
新しい public である players 配列を初期化できます。

83
00:03:11,134 --> 00:03:14,274
これにより、この関数が戻した全ての値を

84
00:03:14,274 --> 00:03:16,274
player 配列に割り当てした

85
00:03:16,274 --> 00:03:18,274
ことになります。

86
00:03:18,274 --> 00:03:20,274
すなわち、 Player タグのある

87
00:03:20,274 --> 00:03:23,405
Aaron、 Bob、 Charlie というオブジェクトを

88
00:03:23,405 --> 00:03:25,405
すべて集合させたことになります。

89
00:03:25,905 --> 00:03:27,905
配列のすぐれた機能のひとつは

90
00:03:27,905 --> 00:03:29,643
ループとの相性が良いということが挙げられます。

91
00:03:29,643 --> 00:03:31,643
シーン上のすべてのプレイヤーの名前を

92
00:03:31,643 --> 00:03:34,554
ログに残したいとします。

93
00:03:34,554 --> 00:03:36,306
この場合、For ループにより

94
00:03:36,306 --> 00:03:37,301
配列の各々の要素に対する処理を行うことが出来ます。

95
00:03:37,801 --> 00:03:39,801
配列にはその長さに関するプロパティというものが存在します。

96
00:03:40,478 --> 00:03:42,295
これにより配列の要素の数が戻されます。

97
00:03:42,295 --> 00:03:44,295
すなわち

98
00:03:44,295 --> 00:03:46,829
ループ で反復させる変数を 0 から始めて

99
00:03:46,829 --> 00:03:48,745
配列の長さよりも短い場合は

100
00:03:48,745 --> 00:03:50,745
そのループを続けるようにすれば、

101
00:03:50,745 --> 00:03:52,745
配列の要素の数だけ

102
00:03:52,745 --> 00:03:54,481
処理回数を反復させることが出来ます。

103
00:03:54,900 --> 00:03:57,626
さらにいえば、反復変数の i は

104
00:03:57,626 --> 00:04:00,289
配列のインデックス番号と等しくなります。

105
00:04:00,289 --> 00:04:03,024
これにより

106
00:04:03,024 --> 00:04:06,423
Player Number 0 is named Aaron という文章を出力できます。

107
00:04:06,854 --> 00:04:10,040
Player 番号の後に

108
00:04:10,040 --> 00:04:12,873
変数 i を続けることで

109
00:04:12,873 --> 00:04:15,454
インデックス番号にあたる数字を表示させて、

110
00:04:15,454 --> 00:04:17,454
最後に、 players ゲームオブジェクト配列における

111
00:04:17,454 --> 00:04:20,135
特定のインデックス番号にある player の名前を

112
00:04:20,135 --> 00:04:22,135
取得します。

113
00:04:23,284 --> 00:04:25,884
ここまで完了したら、スクリプトを保存して戻ります。

114
00:04:26,384 --> 00:04:28,995
Play を押せば、For ループにより 3 つのメッセージがログに

115
00:04:28,995 --> 00:04:31,491
残ることが確認出来ます。

116
00:04:31,491 --> 00:04:33,683
配列の要素の最後に到達するまで、

117
00:04:33,683 --> 00:04:36,028
各アイテムごとにひとつづつアイテムがログに残ります。

118
00:04:36,028 --> 00:04:38,028
配列はスクリプトにより初期化されて、

119
00:04:38,028 --> 00:04:40,028
インスペクタ上で public 変数として

120
00:04:40,028 --> 00:04:42,430
アタッチされたことが確認できます。
